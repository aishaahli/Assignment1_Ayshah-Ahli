# -*- coding: utf-8 -*-
"""Untitled0.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/17bSUrtNvmeYQMWUZY1tUKRDT_TnCGvcU
"""

#QUESTION 1 CODE

import random

# this line defines a class to represent individual chocolates
class Chocolate:
    def __init__(self, weight, price, chocolate_type, choco_id):
        self.weight = weight
        self.price = price
        self.type = chocolate_type
        self.id = choco_id

    # this line provides a meaningful string representation for Chocolate objects
    def __str__(self):
        return f"ID: {self.id}, Type: {self.type}, Weight: {self.weight}g, Price: {self.price} AED"

# this line introduces a function to iteratively distribute chocolates to students
def distribute_chocolates_iterative(chocolates, students):
    distributed_chocolates = []  # Initialize an empty list to store distributed chocolates

    # this line iterates over students and distribute chocolates
    for i, student in enumerate(students):
        if i < len(chocolates):  # this line checks if there are still chocolates to distribute
            distributed_chocolates.append((student, chocolates[i]))  # this line appends a tuple representing the distribution
        else:
            break  # this line breaks out of the loop if all chocolates are distributed

    return distributed_chocolates  # this line returns the list of distributed chocolates

# this line introduces a function to recursively distribute chocolates to students
def distribute_chocolates_recursive(chocolates, students, index=0):
    # Base case: if the index exceeds the length of students or chocolates, return an empty list
    if index == len(students) or index == len(chocolates):
        return []

    # Recursive case: distribute a chocolate to the current student and call the function with the next index
    return [(students[index], chocolates[index])] + distribute_chocolates_recursive(chocolates, students, index + 1)

# Example
chocolates = [
    Chocolate(5, 2, 'Almond', '002'),
    Chocolate(7, 4, 'Peanut Butter', '005'),
    Chocolate(10,3, 'Strawberry', '003'),
    Chocolate(3,6, 'Hazelnut', '004')]

students = ["Student 1", "Student 2", "Student 3", "Student 4"]

# this line shuffles the order of chocolates before distributing iteratively
random.shuffle(chocolates)
iterative_distribution = distribute_chocolates_iterative(chocolates, students)
print("Iterative Distribution:", [(student, str(choco)) for student, choco in iterative_distribution])

# this line the order of chocolates before distributing recursively
random.shuffle(chocolates)
recursive_distribution = distribute_chocolates_recursive(chocolates, students)
print("Recursive Distribution:", [(student, str(choco)) for student, choco in recursive_distribution])

#QUESTION ONE TEST CASE

def test_chocolates_distribution():
    # this line creates a set of chocolates for testing
    test_chocolates = [
        Chocolate(5, 2, 'Almond', '002'),
        Chocolate(7, 4, 'Peanut Butter', '005'),
        Chocolate(10, 3, 'Strawberry', '003'),
        Chocolate(3, 6, 'Hazelnut', '004')]

    # this line creats a list of students
    test_students = ["Test Student 1", "Test Student 2", "Test Student 3", "Test Student 4"]

    # this line shuffles the order of chocolates for iterative distribution
    random.shuffle(test_chocolates)
    iterative_result = distribute_chocolates_iterative(test_chocolates.copy(), test_students)

    # this line shuffles the order of chocolates for recursive distribution
    random.shuffle(test_chocolates)
    recursive_result = distribute_chocolates_recursive(test_chocolates.copy(), test_students)

    # this line prints the results for verification
    print("Original Chocolates:", [str(choco) for choco in test_chocolates])
    print("Iterative Distribution:", [(student, str(choco)) for student, choco in iterative_result])
    print("Recursive Distribution:", [(student, str(choco)) for student, choco in recursive_result])

# this line runs the test case
test_chocolates_distribution()

#QUESTION 2 CODE

def merge_sort(chocolates, key):
    if len(chocolates) > 1:
        mid = len(chocolates) // 2
        left_half = chocolates[:mid]
        right_half = chocolates[mid:]

        merge_sort(left_half, key)
        merge_sort(right_half, key)

        i = j = k = 0

        while i < len(left_half) and j < len(right_half):
            if getattr(left_half[i][1], key) < getattr(right_half[j][1], key):
                chocolates[k] = left_half[i]
                i += 1
            else:
                chocolates[k] = right_half[j]
                j += 1
            k += 1

        while i < len(left_half):
            chocolates[k] = left_half[i]
            i += 1
            k += 1

        while j < len(right_half):
            chocolates[k] = right_half[j]
            j += 1
            k += 1

sorted_by_weight = sort_chocolates(chocolates, students, 'weight')
print("Sorted by Weight:", [student for student, _ in sorted_by_weight])

sorted_by_price = sort_chocolates(chocolates, students, 'price')
print("Sorted by Price:", [student for student, _ in sorted_by_price])

#QUESTION 2 TEST CASE

import random

# this line defines the Chocolate class and distribution functions if not already defined

class Chocolate:
    def __init__(self, weight, price, chocolate_type, choco_id):
        self.weight = weight
        self.price = price
        self.type = chocolate_type
        self.id = choco_id

    def __str__(self):
        return f"ID: {self.id}, Type: {self.type}, Weight: {self.weight}g, Price: {self.price} AED"

def distribute_chocolates_iterative(chocolates, students):
    distributed_chocolates = []
    for i, student in enumerate(students):
        if i < len(chocolates):
            distributed_chocolates.append((student, chocolates[i]))
        else:
            break
    return distributed_chocolates

def distribute_chocolates_recursive(chocolates, students, index=0):
    if index == len(students) or index == len(chocolates):
        return []
    return [(students[index], chocolates[index])] + distribute_chocolates_recursive(chocolates, students, index + 1)

# this line defines the merge_sort function
def merge_sort(chocolates, key):
    if len(chocolates) > 1:
        mid = len(chocolates) // 2
        left_half = chocolates[:mid]
        right_half = chocolates[mid:]

        merge_sort(left_half, key)
        merge_sort(right_half, key)

        i = j = k = 0

        while i < len(left_half) and j < len(right_half):
            if getattr(left_half[i], key) < getattr(right_half[j], key):
                chocolates[k] = left_half[i]
                i += 1
            else:
                chocolates[k] = right_half[j]
                j += 1
            k += 1

        while i < len(left_half):
            chocolates[k] = left_half[i]
            i += 1
            k += 1

        while j < len(right_half):
            chocolates[k] = right_half[j]
            j += 1
            k += 1

# this line is the test case for Merge Sort
def test_merge_sort():
    test_chocolates = [
        Chocolate(5, 2, 'Almond', '002'),
        Chocolate(7, 4, 'Peanut Butter', '005'),
        Chocolate(10, 3, 'Strawberry', '003'),
        Chocolate(3, 6, 'Hazelnut', '004')
    ]

    test_students = ["Test Student 1", "Test Student 2", "Test Student 3", "Test Student 4"]

    random.shuffle(test_chocolates)

    # this line makes a copy for sorting and comparison
    chocolates_copy = test_chocolates.copy()

    merge_sort(test_chocolates, 'weight')
    sorted_by_weight = distribute_chocolates_iterative(test_chocolates, test_students)

    # this line resets to the original order for the next sorting
    test_chocolates = chocolates_copy.copy()

    random.shuffle(test_chocolates)
    merge_sort(test_chocolates, 'price')
    sorted_by_price = distribute_chocolates_recursive(test_chocolates, test_students)

    print("Original Chocolates:", [str(choco) for choco in chocolates_copy])
    print("Sorted by Weight:", [(student, str(choco)) for student, choco in sorted_by_weight])
    print("Sorted by Price:", [(student, str(choco)) for student, choco in sorted_by_price])

# this line runs the test case
test_merge_sort()

#QUESTION 3 CODE

def find_student_by_key(distributed_chocolates, key, target_value):
    for student, chocolate in distributed_chocolates:
        if getattr(chocolate, key) == target_value:
            return student
    return None
target_weight = 7
target_price = 4

student_with_target_weight = find_student_by_key(iterative_distribution, 'weight', target_weight)
student_with_target_price = find_student_by_key(recursive_distribution, 'price', target_price)

print(f"Student holding chocolate with weight {target_weight}g: {student_with_target_weight}")
print(f"Student holding chocolate with price {target_price} AED: {student_with_target_price}")

#QUESTION 3 TEST CASE

def test_find_student_by_key():

    # this line defines the Chocolate class and distribute functions if not already defined
    class Chocolate:
      def __init__(self, weight, price, chocolate_type, choco_id):
        self.weight = weight
        self.price = price
        self.type = chocolate_type
        self.id = choco_id

    def __str__(self):
        return f"ID: {self.id}, Type: {self.type}, Weight: {self.weight}g, Price: {self.price} AED"


    def distribute_chocolates_iterative(chocolates, students):
        distributed_chocolates = []
        for i, student in enumerate(students):
            if i < len(chocolates):
                distributed_chocolates.append((student, chocolates[i]))
            else:
                break
        return distributed_chocolates

    def distribute_chocolates_recursive(chocolates, students, index=0):
        if index == len(students) or index == len(chocolates):
            return []
        return [(students[index], chocolates[index])] + distribute_chocolates_recursive(chocolates, students, index + 1)

    # this line defines the find_student_by_key function
    def find_student_by_key(distributed_chocolates, key, target_value):
        for student, chocolate in distributed_chocolates:
            if getattr(chocolate, key) == target_value:
                return student
        return None

    # this line defines a set of chocolates for testing
    test_chocolates = [
        Chocolate(5, 2, 'Almond', '002'),
        Chocolate(7, 4, 'Peanut Butter', '005'),
        Chocolate(10, 3, 'Strawberry', '003'),
        Chocolate(3, 6, 'Hazelnut', '004')]

    # this line defines a list of students
    test_students = ["Test Student 1", "Test Student 2", "Test Student 3", "Test Student 4"]

    # this line shuffles the order of chocolates before distributing iteratively
    random.shuffle(test_chocolates)
    iterative_distribution = distribute_chocolates_iterative(test_chocolates.copy(), test_students)

    # this line shuffles the order of chocolates before distributing recursively
    random.shuffle(test_chocolates)
    recursive_distribution = distribute_chocolates_recursive(test_chocolates.copy(), test_students)

    # this line defines target weight and price for testing
    target_weight = 7
    target_price = 4

    # this line searches for the student holding a chocolate with the specified weight in the iteratively distributed chocolates
    student_with_target_weight_iterative = find_student_by_key(iterative_distribution, 'weight', target_weight)

    # this line searches for the student holding a chocolate with the specified price in the recursively distributed chocolates
    student_with_target_price_recursive = find_student_by_key(recursive_distribution, 'price', target_price)

    # this line prints the results for verification

    print(f"Student holding chocolate with weight {target_weight}g (Iterative): {student_with_target_weight_iterative}")
    print(f"Student holding chocolate with price {target_price} AED (Recursive): {student_with_target_price_recursive}")

# this line runs the test case
test_find_student_by_key()